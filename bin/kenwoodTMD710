#! /usr/bin/env ruby

# Basic serial io using 'serialport'
# check to see if you have any remnant of ruby-serialport:
# cd ~/.rvm
# find . -name ruby-serialport*
# Delete the directories you find with the find command.
# Install serialport if it's not already done:
# gem install serialport (NOT ruby-serialport !!!)

require 'net/http'
require 'time'
require 'json'
require 'serialport'

def log_entry entry
  log_file = File.new( @log_file_name, 'a' )
  log_file.puts "#{Time.now.utc} #{entry}"
  log_file.close
end

def update( data, uri )
  begin
    req = Net::HTTP::Post.new(uri.path, 
          initheader = {'Content-Type' =>'application/json'} )
    #req.set_form_data( data )
    req.body = data
    res = Net::HTTP.start(uri.hostname, uri.port) do |http|
      http.request(req)
    end
    result = "#{res.code} #{res.message} #{uri.to_s}"
  rescue Errno::ECONNREFUSED
    result = "Server not available: #{uri.to_s}"
  rescue
    result = "Bad request #{uri.to_s} #{data}"
  end
end

def aprs_str_to_json( aprs_str )
  # "WB9SKY-11>APOT02,KA9SCF-15,WIDE1,K9ESV-10,WIDE2*,qAR,W9TMW:/151435z4058.42N/08754.43WO103/024 12.1V 21CTest/A=023677"
  # "WB9SKY-11>APBL10,N9IO*,WIDE2-1:!4106.07N/08755.13WO317/025/A=005243Adler High Altitude Balloon"
  # "KC9LHW-11>APBL10,WIDE1-1,WIDE2-1:!4106.18N/08755.31WO309/022/A=005939Adler Planetarium Balloon"
  puts "aprs_str:#{aprs_str}"
  call_sign = aprs_str.split(">")[0]
  #puts "@filter:#{@filter} class:#{@filter.class}"
  if @filter.include?( call_sign.split("-")[0] )
    temp = aprs_str.split(":")[1]
    data_type = temp[0]
    lat = ( temp[1..2].to_f + temp[3..7].to_f / 60.0 ) * ( temp[8] == "N" ? 1 : -1 )
    lon = ( temp[10..12].to_f + temp[13..17].to_f / 60.0 ) * ( temp[18] == "E" ? 1 : -1 )
    course = temp[20..22].to_i
    speed = temp[24..26].to_f * @knots2mps
    sym_id = temp[19]
    sym_code = temp[27]
    alt = temp.split("A=")[1][0..5].to_f * @ft2m
    { :time => @sim_time, :lat => lat, :alt => alt, :lon => lon, 
      :heading => course, :vg => speed, :id_source => @id_source, 
      :ident => call_sign }.to_json  
  end
end

def char_in( c )
  result = nil
  if c == "\n" || c == "\r"
    if !@eol_flag
      result = @msg
      @msg = ""
      @eol_flag = true
    else
      @eol_flag = false
    end
  else
    @msg += c
    @eol_flag = false
  end
  return result
end
#puts "start"
tty_port = '/dev/ttyUSB0' #for example
baud_rate = 9600
data_bits = 8
stop_bits = 1
parity = SerialPort::NONE
#puts "ARGV:#{ARGV.to_s}"
@serv_uri = ARGV[0] ? ARGV[0] : "http://localhost:3000" # host uri, e.g., http://localhost:3000
@id_source = ARGV[1] ? ARGV[1] : "123456" # beacon_receiver id
@filter = ["WB9SKY", "KC9LHW", "KC9LIG"] #JSON.parse(ARGV[2]) # Array of call signs
@uri = URI( "#{@serv_uri}/points" )
@log_file_name = "log/kenwoodTMD700.log"

@knots2mps = 0.51444444444 # m/s
@ft2m = 0.3048 # m

@msg_buffer = ""
@msg = ""
@eol_flag = false
@msgRdy = false
@wait = 1

#puts "init"

#unless @serv_uri && @id_source && @filter
#  log_entry( "ERROR: Must have three arguments.")
#  puts "ERROR: kenwoodTMD710 driver not started. Requires three arguments " +
#       "ARGS: #{ARGV}"
#  exit
#end
#
last_log_entry = ""
log_entry( "---------------")
log_entry( "---------------")
log_entry( "Started #{@cmd} on device id:#{@id_source} to server #{@serv_uri}")
#puts "log started"
Signal.trap( "TERM" ) do
  log_entry( "kenwoodTMD710 terminated by SIGTERM")
  exit
end
#puts "init radio"
begin
  sp = SerialPort.new( 
    tty_port, baud_rate, data_bits, stop_bits, parity)

  init = File.open( "bin/TM-D710.CMD", 'r' )
  line = ""
  while !init.eof? && line != "[INIT_COMMANDS]"
    line = init.readline().chomp()
    #puts line
  end

  Thread.new {
    while true do
      result = char_in( sp.getc )
      puts result if result
#      form_data = aprs_str_to_json( result ) if msg_check( result )
#      result = update( form_data, @uri )
#      puts form_data
#      log_entry( result ) unless result == last_log_entry
#      last_log_entry = result
    end
  }
  line = init.readline().chomp()
  while !init.eof? && !line.start_with?( "[EXIT_COMMANDS]" )
    if line.length > 0 && !line.start_with?( ';' )
      cmd = line.split('!')[0]
      sleep @wait
      if cmd.start_with?( '^' )
        sp.write( "\x03\r" ) if cmd[1] == 'C'
        sleep cmd[2].to_i if cmd[1] == 'W'
      else
        sp.write( cmd + "\r" )
      end
    end
    line = init.readline().chomp()
  end
  while true do
    
  end
  init.close()
  
rescue => ex
  puts ex.message
end